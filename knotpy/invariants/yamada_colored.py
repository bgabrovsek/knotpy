__all__ = ['colored_yamada_polynomial']
__version__ = '0.1'
__author__ = 'Boštjan Gabrovšek <bostjan.gabrovsek@pef.uni-lj.si>'

NUM_COL_EP = None
__DEBUG_YAMADA = False

from sympy import Expr, expand, Integer, symbols, Symbol
from collections import deque

from knotpy import to_knotpy_notation
from knotpy.algorithms.canonical import canonical
from knotpy.algorithms.topology import loops, bridges, is_loop, is_bridge
from knotpy.classes.planardiagram import PlanarDiagram
from knotpy.algorithms.orientation import unoriented
from knotpy.manipulation.contract import contract_arc
from knotpy.manipulation.remove import remove_arc, remove_loops, remove_empty_nodes
from knotpy.manipulation.attributes import clear_attributes
from knotpy.notation.native import from_knotpy_notation
from knotpy.algorithms.skein import smoothen_crossing, crossing_to_vertex
from knotpy.reidemeister.simplify import simplify_crossing_reducing


def _is_arc_colored(arc):
    ep1, ep2 = arc
    return "color" in ep1.attr or "color" in ep2.attr


def _test_if_colored(k:PlanarDiagram, text):
    colored_ep = {ep for ep in k.endpoints if "color" in ep}
    if NUM_COL_EP:
        if len(colored_ep) != NUM_COL_EP:
            print("Not colored", k)
            print(text)
            raise ValueError(f"Two endpoints are not colored (colored={len(colored_ep)}).")

    #assert len({ep for ep in k.endpoints if "color" in ep}) == 2, f"{k}"




def state_sum_yamada(k: PlanarDiagram):
    """
    Calculate the Yamada polynomial states of a planar diagram by iteratively
    applying smoothing operations (remove crossings via "A", "B", and "X" state)
    on crossings and reducing the diagram step by step.
    Each state in the result is represented as a reduced diagram without crossings.

    Args:
        k (PlanarDiagram): The initial planar diagram for which the Yamada polynomial
            states are to be calculated.

    Returns:
        list: A list of diagrams (states) obtained after all crossings have been
            resolved through the application of specific Yamada smoothing methods.
    """

    # Store in diagram's attributes the number of A/B/X smoothings performed.
    k.attr["_A"] = 0
    k.attr["_B"] = 0
    k.attr["_X"] = 0

    stack = deque()  # use a stack to simulate recursive calls for the smoothened states
    stack.append(k)  # add the initial diagram to the stack
    states = []  # here we store the resulting diagrams without crossings (states)

    polynomials = []

    while stack:
        k = stack.pop()
        simplify_crossing_reducing(k, inplace=True)

        if k.crossings:
            crossing = next(iter(k.crossings))  # pop a crossing to smoothen
            kA = smoothen_crossing(k, crossing_for_smoothing=crossing, method="A")
            kB = smoothen_crossing(k, crossing_for_smoothing=crossing, method="B")
            kX = crossing_to_vertex(k, crossing=crossing)

            kA.attr["_A"] = k.attr["_A"] + 1
            kB.attr["_B"] = k.attr["_B"] + 1
            kX.attr["_X"] = k.attr["_X"] + 1

            stack.extend([kA, kB, kX])
        else:
            states.append(k)  # if there are no crossings, push it to the resulting states

    return states


def _deletion_contraction_uncolored_arcs(k: PlanarDiagram) -> list:
    """
    Performs deletion-contraction operation on the uncolored arcs of a planar graph.
    The function systematically explores all possible states generated by either deleting
    or contracting an arc, and resolves them into a final list of states.

    Args:
        k: A planar graph
    Returns:
        list: A list of resolved graph-like structures, each representing a unique
        state after applying deletion-contraction operations.
    """

    # count number of deletions and contractions, store this information in the graph itself
    k.attr["_deletions"] = 0
    k.attr["_contractions"] = 0

    resolved = []  # list of resolved states (graph containing only bridges and loops)
    stack = deque()
    stack.append(k)

    while stack:
        k = stack.pop()

        has_regular_arcs = False
        for arc in k.arcs:

            if _is_arc_colored(arc):
                # do not contract colored arcs
                continue

            if is_loop(k, arc) or is_bridge(k, arc):
                # do not contract bridges
                continue



            k_delete = remove_arc(k, arc_for_removing=arc, inplace=False)

            _test_if_colored(k_delete, f"DEL f{k} arc {arc}")

            k_delete.attr["_deletions"] += k.attr["_deletions"] + 1


            k_contract = contract_arc(k, arc_for_contracting=arc, inplace=False)

            _test_if_colored(k_contract, f"CON f{k} arc {arc}")


            k_contract.attr["_contractions"] += k.attr["_contractions"] + 1
            stack.append(k_delete)
            stack.append(k_contract)
            has_regular_arcs = True
            break  # TODO: optimize

        if not has_regular_arcs:
            resolved.append(k)
    return resolved


def _remove_uncolored_loops(k: PlanarDiagram) -> int:
    """Remove loops that are not colored and return how many loops were removed. Inplace.
    """

    number_of_loops_removed = 0

    while True:

        # find a loop
        for arc in k.arcs:

            if _is_arc_colored(arc):
                # do not remove colored loops
                continue

            if is_loop(k, arc):
                # remove the loop
                remove_arc(k, arc, inplace=True)
                number_of_loops_removed += 1
                break
        # no loops found
        break

    return number_of_loops_removed


def _contract_non_loop_regular_arcs(g:PlanarDiagram):
    """ Contract all uncolored non-loop arcs in a planar graph."""

    arcs_were_contracted = True  # so the loops starts

    while arcs_were_contracted:

        arcs_were_contracted = False

        for arc in g.arcs:
            if _is_arc_colored(arc):
                continue
            if is_loop(g, arc):
                continue
            contract_arc(g, arc)
            # rerun the inner for loop for every change made
            arcs_were_contracted = True
            break



def _evaluate_state(g: PlanarDiagram, variable="A"):
    """Evaluate single "Yamada" state after crossing smoothing and deletion-contraction.
    The input is a planar graph containing uncolored bridges and uncolored loops.
    There can be any number of colored arcs without any conditions.
    """

    A = variable if isinstance(variable, Symbol) else symbols(variable)
    _sigma = (A + 1 + A ** (-1))

    if bridges(g):
        # if there are any bridges (colored or uncolored), the state is 0
        return Integer(0), None

    # start removing loops
    # TODO: the sign of +-sigma^n can figured out by the number of components and number of loops removed

    coefficient = Integer(1)
    loop_removed = True
    while loop_removed:

        loop_removed = False
        for arc in g.arcs:
            if is_loop(g, arc) and not _is_arc_colored(arc):
                is_disjoint_loop = all(g.degree(ep.node) == 2 for ep in arc)  # make faster
                if __DEBUG_YAMADA: print("is disjoint loop", is_disjoint_loop)
                coefficient *= _sigma if is_disjoint_loop else -_sigma
                remove_arc(g, arc, inplace=True)
                loop_removed = True
                break

    #number_of_uncolored_loops = _remove_uncolored_loops(g)
    _contract_non_loop_regular_arcs(g)

    remove_empty_nodes(g)

    return coefficient, g



def colored_yamada_polynomial(k: PlanarDiagram, variable="A", normalize=True):
    """
    Computes the Yamada polynomial of a given planar diagram using the skein relation and the contraction-deletion
    operation as defined in
    [Yamada, S. (1989). An invariant of spatial graphs. Journal of Graph Theory, 13(5), 537-551].

    Args:
        k (PlanarDiagram): The input planar diagram representation
        variable (str | Symbol, optional): The variable used to construct the polynomial.
            Defaults to "A". Can be a string or a SymPy symbol representing the variable.
        normalize (bool, optional): Indicates whether to normalize the computed polynomial
            by shifting the lowest degree term to ensure consistent representation.
            Defaults to True.

    Returns:
        sympy.Expr: The expanded polynomial expression representing the Yamada polynomial
        of the input diagram.

    Raises:
        ValueError: If the deletion-contraction process results in mismatched loop
            and arc counts, which violates the consistency of the diagram's graphical
            properties.
    """

    # TODO: simplify diagrams mid-states and implement framing support
    # TODO: use caching
    # TODO: use precomputed values for smaller diagrams
    # TODO: speed up contraction-deletion operation

    # variable init
    A = variable if isinstance(variable, Symbol) else symbols(variable)
    _sigma = (A + 1 + A ** (-1))

    # input diagram init
    k = unoriented(k) if k.is_oriented() else k.copy()
    k.framing = 0  # framing not yet supported

    # remove crossing via skein relation
    no_crossing_states = state_sum_yamada(k)

    for g in no_crossing_states:

        if __DEBUG_YAMADA:
            print()
            print()
            print("***")
            print(g)
            print(to_knotpy_notation(g))
            print("***")

        dc = _deletion_contraction_uncolored_arcs(g)

        # jst test that exactly 2 edges are colored (remove this after testing)
        for h in dc:
            if NUM_COL_EP:
                assert sum(["color" in ep for ep in h.endpoints]) == NUM_COL_EP

    if __DEBUG_YAMADA: print("\nDEL CONTR\n")

    # contract non-loop, non-bridge, uncolored arcs
    deletion_contraction_states = [(A ** (g.attr["A"] - g.attr["B"]), h)
                                   for g in no_crossing_states
                                   for h in _deletion_contraction_uncolored_arcs(g)]


    # jsut a test, remove this
    for c, h in deletion_contraction_states:
        if NUM_COL_EP:
            assert sum(["color" in ep for ep in h.endpoints]) == NUM_COL_EP
    graph_module = dict()  # keys are graph, values are polynomials

    for coeff, h in deletion_contraction_states:

        if __DEBUG_YAMADA: print("*", h, coeff)

        inner_coeff, state_graph = _evaluate_state(h)
        if state_graph is None or inner_coeff == 0:
            if __DEBUG_YAMADA: print("eval", 0)
            continue

        if __DEBUG_YAMADA: print("eval", state_graph, inner_coeff)


        clear_attributes(state_graph)
        state_graph = canonical(state_graph)
        if state_graph not in graph_module:
            graph_module[state_graph] = Integer(0)

        if __DEBUG_YAMADA: print(" + ", coeff * inner_coeff)
        graph_module[state_graph] += coeff * inner_coeff
        if __DEBUG_YAMADA: print("=", graph_module[state_graph])
    if not graph_module:
        return Integer(0)

    if __DEBUG_YAMADA: print("MODULE", module2str(graph_module))

    #expand all
    for g, c in graph_module.items():
        graph_module[g] = expand(c)

    if normalize:
        # Normalize by multiplying by A^(2n), so that the lowest term of the polynomial is 1 (constant) or A.
        # This normalization translates to adding some framing.
        # TODO: normalize by framing and writhe, not by "1 or A" (this is really the proper way)
        lowest_exponent = min(term.as_coeff_exponent(A)[1] for polynomial in graph_module.values() for term in polynomial.as_ordered_terms())
        for g, c in graph_module.items():
            graph_module[g] = expand(c * A**(-(lowest_exponent // 2) * 2))

        # r4 kinks TODO: join with above
        lowest_exponent = min(term.as_coeff_exponent(A)[1] for polynomial in graph_module.values() for term in
                              polynomial.as_ordered_terms())
        for g, c in graph_module.items():
            graph_module[g] = expand(c * (-A) ** (-lowest_exponent))

        #lowest_exponent = min(term.as_coeff_exponent(A)[1] for term in polynomial.as_ordered_terms())
        #polynomial = expand(polynomial * (-A)**(-lowest_exponent))


    return graph_module

def module2str(m):
    #for g in m.values():
    return " + ".join(f"({c})[{str(g).replace('Diagram ','')}]" for g, c in m.items())

if __name__ == "__main__":
    # colored yamada test
    code_theta = "a=V(b0 c0 d3) b=V(a0 d2 e3) c=X(a1 e2 e1 d0) d=X(c3 e0 b1 a2) e=X(d1 c2 c1 b2) [;;a0:{'color'=1} b0:{'color'=1}]"
    k = from_knotpy_notation(code_theta)
    print(k)


    y = colored_yamada_polynomial(k)


    print(module2str(y))

